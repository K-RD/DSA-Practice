# Practical Questions for Design & Analysis of Algorithms (DAA)

## Module 1: Introduction to Algorithm Analysis
1. Write a program to analyze the best, average, and worst-case time complexities of **linear search** and **binary search**.
2. Implement sorting algorithms (e.g., **bubble sort**, **insertion sort**) and analyze their time complexities for different input sizes.
3. Solve recurrence relations using:
   - Substitution method
   - Recursion tree method
   - Master’s theorem
4. Implement and analyze a recursive function for:
   - Calculating factorial
   - Generating the Fibonacci series

---

## Module 2: Divide and Conquer
5. Write a program for **binary search** and analyze its performance.
6. Implement and compare **Quick Sort** and **Merge Sort** algorithms.
7. Implement the **Median-of-Medians algorithm** to find the k-th smallest element in an array.
8. Write a program to perform **Strassen’s matrix multiplication** and compare it with standard matrix multiplication.
9. Implement **Karatsuba’s algorithm** for fast multiplication of large integers.

---

## Module 3: Algorithm Design Paradigms

### Greedy Algorithms
10. Implement **Kruskal's algorithm** to find the Minimum Spanning Tree (MST).
11. Implement **Prim’s algorithm** for the MST problem.
12. Solve the **0/1 knapsack problem** using the greedy approach.
13. Implement **Huffman coding** for character encoding.
14. Solve the **Job Sequencing problem**.

### Dynamic Programming
15. Write a program to calculate the **Fibonacci series** using dynamic programming.
16. Solve the **Matrix Chain Multiplication** problem.
17. Implement the **0/1 Knapsack Problem** using dynamic programming.
18. Solve the **Longest Common Subsequence (LCS)** problem.
19. Solve the **Travelling Salesman Problem (TSP)** using dynamic programming.
20. Implement the **Rod Cutting Problem**.
21. Solve the **Bin Packing Problem**.

### Backtracking
22. Solve the **N-Queens problem**.
23. Implement a backtracking algorithm to solve the **Sudoku puzzle**.

### Branch and Bound
24. Solve the **0/1 Knapsack Problem** using Branch-and-Bound.
25. Solve the **Travelling Salesman Problem (TSP)** using Branch-and-Bound.

---

## Module 4: Graph and Tree Algorithms
26. Write programs for graph representations:
    - **Adjacency list**
    - **Adjacency matrix**
27. Implement **Depth First Search (DFS)** and **Breadth First Search (BFS)** for a graph.
28. Write a program to solve the **single-source shortest path problem** using:
    - **Dijkstra’s algorithm**
    - **Bellman-Ford algorithm**
29. Implement **Floyd-Warshall’s algorithm** for all-pairs shortest paths.
30. Write a program to perform **Topological Sorting** of a Directed Acyclic Graph (DAG).
31. Implement the **Ford-Fulkerson algorithm** for finding the maximum flow in a network.
32. Write a program to find all **connected components** in an undirected graph.

---

## Module 5: Tractable and Intractable Problems
33. Demonstrate an NP-complete problem such as the **Subset Sum Problem**.
34. Write a simple **approximation algorithm** for the Travelling Salesman Problem.
35. Implement **randomized quicksort** and compare it with deterministic quicksort.
36. Implement a randomized algorithm to find the **k-th smallest element** in an array.

